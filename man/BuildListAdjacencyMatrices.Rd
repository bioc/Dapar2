% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agregation.R
\name{BuildListAdjacencyMatrices}
\alias{BuildListAdjacencyMatrices}
\title{Function matrix of appartenance group}
\usage{
BuildListAdjacencyMatrices(plist, names, type = c("All", "Shared", "Specific"))
}
\arguments{
\item{plist}{A vector of proteins ids. The length of this vector is equal to the number of peptides one wants to aggregate, each line of it correspond
to a peptide. Each element of this vector is either one element or a combination of elements seperated by a comma.}

\item{names}{A vector of names of peptides (a unique Id). The size of this vector is equal to the size of the parameter 'plist'.}

\item{type}{A vector of type of adjacency matrices to include in the return value. Values are : 'All' for 
the matrix containing all peptides, 'Shared' for the matrix which contains only the shared peptides v=between proteins,
'Specific' for the matrix which contains only the specific peptides. Default value for type is all these three matrices.}
}
\value{
A list of three adjacency matrices. 1 - the matrix contains all peptides (shared and specific), 2 - 
the matrix contains only the peptides shared between proteins, 3 - the matrix contains only specific peptides.
}
\description{
All teh matrices have the same dimensions. The first matrix correspond to all the peptides, the second one contains 
only the peptides shared with several proteins and the last matrix contains only the specific peptides. These matrices are useful 
is one aggregate with only a certain type of peptides or all of them.
}
\details{
#' Method to create a binary matrix with proteins in columns and peptides 
#' in lines on a \code{MSnSet} object (peptides)
#' 
#' @title Function matrix of appartenance group
#' @param pg A vector of xxxxx
#' @param names The names of peptides xxxx
#' @param unique A boolean to indicate whether only the unique peptides must 
#' be considered (TRUE) or if the shared peptides have to 
#' be integrated (FALSE).
#' @return A binary matrix  
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_pept, package='DAPARdata2')
#' PG <- rowData(Exp1_R25_pept[['original']])[,metadata(Exp1_R25_pept)$parentProtId]
#' names <- names((Exp1_R25_pept[['original']]))
#' X <- BuildAdjacencyMatrix(PG, names, TRUE)
#' @export
BuildAdjacencyMatrix <- function(pg, names, unique=FALSE){
  PG.l <- strsplit(as.character(pg), split=";", fixed=TRUE)
  
  t <- table(data.frame(A=rep(seq_along(PG.l), lengths(PG.l)), B=unlist(PG.l)))
  
  if (unique == TRUE){
    ll <- which(rowSums(t)>1)
    if (length(ll) > 0) {
      t[ll,] <- 0
    }
  }
  
  X <- Matrix::Matrix(t, dimnames = list(names, colnames(t))
  )
  
  return(X)
}
Method to create a list of three binary matrices with proteins in columns and peptides 
in lines.
}
\examples{
utils::data(Exp1_R25_pept, package='DAPARdata2')
plist <- rowData(Exp1_R25_pept[['original']][1:1000,])[1:1000,metadata(Exp1_R25_pept)$parentProtId]
names <- names((Exp1_R25_pept[['original']])[1:1000])
X <- BuildListAdjacencyMatrices(plist, names, type=c('All', 'Shared', 'Specific'))
}
\author{
Samuel Wieczorek
}
